### LCA => Lowest Common Ancestor

기존의 lca를 구하는 방법은 깊이를 같게 해주고 한칸씩 따라가는 형식으로
lca를 찾는데 O(n) 쿼리가 있으면 m * n 이 걸립니다.

dp를 이용한 lca는 O(log n) 으로 줄여 m log n 의 시간복잡도로 해결해 보겠습니다.

lca를 구할 때 필요한 두가지는 
p 와 d  p는 조상 d는 노드의 깊이라고 하겠습니다.

p[a][0]와 d 는 dfs 나 bfs로 해결 할 수 있습니다.

다음 식을 이해 할 수 있어야 합니다.

p[a][t] =>  a의 2^t번째 조상을 저장
p[a][t] = p[p[a][t-1]][t-1]       


아래 그림에서 p[a][2] = p[p[a][1]][1] 이고  
p[a][1] = k;
p[k][1] = r;
p[a][2] = r; 
이 과정을 이해합니다. 이 결과로 한 노드에서 2^t 번째 조상이 누구인지 알 수 있습니다.

그럼 이 작업을 한 이유가 무엇일까요..  lca는 직관적입니다. 두 정점의 깊이가 다르면 같게 하고 깊이가 같을 때부터 한단계씩
올라가면서 lca를 구하는데 먼저 이 깊이를 같게하는 시간을 줄여보겠습니다.

예를들어 두 노드의 깊이 차이가 11가 난다고 하겠습니다. 그럼 기존의 방식은 노드에서 부모로 그 부모에서 또 그 부모로
10번의 과정이 필요한데요. 저희가 구해놓은 p 배열을 이용하면 1011(2) 4번만에 깊이를 구할 수 있습니다.

여기서도 좀 어려운데 a의 11번째 조상을 찾는과정은 
p[a][0] = k1;
p[k1][1] = k2;
p[k2][3] = k3;       => 이과정으로 a의 11번째 조상을 찾을 수 있습니다. 이진수를 이해하셔야 합니다.

깊이를 같게 만드는 과정을 빠르게 줄였고 이제 한단계씩 올라가면서 부모가 같으면 lca지만 여기서도 시간을 줄일 수 있습니다.

한단계씩 올라가는것이아닌 먼 조상부터 내려오면서 판단하는 것 입니다.
u v 두 노드의 먼 조상부터 p[u][t] != p[v][t] 가 같지 않으면 그 사이에 공통조상이 있는것을 알 수 있고 

이때 u와 v를 업데이트하면서 다시 조상을 검사하는 과정을 반복하면 p[u][0] == p[v][0] == lca 입니다.

다시 설명하면 t+1에서 공통조상이 같은데 t에서 다르다면 그 사이에 공통 조상이 있다는 것을 알 수 있고
u와 v를 그 지점으로 옮겨 다시 lca를 찾는 것 입니다.

그림을 그려가며 이해하는것이 좋습니다.

justhishui님의 블로그를 참고했습니다.



